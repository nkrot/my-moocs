(* Coursera Programming Languages, Homework 3, Provided Code *)

exception NoAnswer

datatype pattern = Wildcard
		         | Variable of string
		         | UnitP
		         | ConstP of int
		         | TupleP of pattern list
		         | ConstructorP of string * pattern

datatype valu = Const of int
	          | Unit
	          | Tuple of valu list
	          | Constructor of string * valu

fun g f1 f2 p =
    let 
	    val r = g f1 f2 
    in
	    case p of
	        Wildcard          => f1 ()
	      | Variable x        => f2 x
	      | TupleP ps         => List.foldl (fn (p,i) => (r p) + i) 0 ps
	      | ConstructorP(_,p) => r p
	      | _                 => 0
    end

(**** for the challenge problem only ****)

datatype typ = Anything
	     | UnitT
	     | IntT
	     | TupleT of typ list
	     | Datatype of string

(**** you can put all your code here ****)

(*
1. Write a function only_capitals that takes a string list and returns a string list that has only
  the strings in the argument that start with an uppercase letter. Assume all strings have at least 1
  character. Use List.filter, Char.isUpper, and String.sub to make a 1-2 line solution.
*)
fun only_capitals sl =
    let val starts_with_uppercase = fn s => Char.isUpper(String.sub(s,0))
    in
        List.filter starts_with_uppercase sl
    end

(*
2. Write a function longest_string1 that takes a string list and returns the longest string
   in the list. If the list is empty, return "".
   In the case of a tie, return the string closest to the beginning of the list.
   Use foldl, String.size, and no recursion (other than the implementation of foldl is recursive)
*)

fun longest_string1 sl =
    let val longest_of = fn (s1,s2) => if size(s1) > size(s2) then s1 else s2
    in
        foldl longest_of  ""  sl
    end

(*
3. Write a function longest_string2 that is exactly like longest_string1 except
   in the case of ties it returns the string closest to the end of the list.
   Your solution should be almost an exact copy of longest_string1.
   Still use foldl and String.size.
*)

fun longest_string2 sl =
    let val longest_of = fn (s1,s2) => if size(s1) >= size(s2) then s1 else s2
    in
        foldl longest_of  ""  sl
    end

(*
4. Write functions longest_string_helper, longest_string3, and longest_string4 such that:
   * longest_string3 has the same behavior as longest_string1 and longest_string4
     has the same behavior as longest_string2.
   * longest_string_helper has type (int * int -> bool) -> string list -> string
     (notice the currying). This function will look a lot like longest_string1 and
     longest_string2 but is more general because it takes a function as an argument.
   * longest_string3 and longest_string4 are defined with val-bindings and partial 
     applications of longest_string_helper.
*)

fun longest_string_helper is_longer sl =
    let val longest_of = fn (s1,s2) => if is_longer(size(s1), size(s2)) then s1 else s2
    in
        List.foldl longest_of "" sl
    end

fun longest_string3 sl =
    let val longest_length = fn (l1,l2) => l1 > l2
    in
        longest_string_helper longest_length sl
    end

fun longest_string4 sl =
    let val longest_length = fn (l1,l2) => l1 >= l2
    in
        longest_string_helper longest_length sl
    end

(*
5. Write a function longest_capitalized that takes a string list and returns
   the longest string in the list that begins with an uppercase letter
   (or "" if there are no such strings).
   Use a val-binding and the ML library’s o operator for composing functions. 
   Resolve ties like in problem 2.
*)

fun longest_capitalized sl =
    (longest_string2 o only_capitals) sl

(*
6. Write a function rev_string that takes a string and returns the string
   that is the same characters in reverse order.
   Use ML’s o operator, the library function rev for reversing lists, and
   two library functions in the String module.
  (Browse the module documentation to find the most useful functions.)
*)

fun rev_string str =
    (implode o rev o explode) str

(********************************************************************)

(*
7. Write a function first_answer of type (’a -> ’b option) -> ’a list -> ’b
   (notice the 2 arguments are curried). The first argument should be
   applied to elements of the second argument in order until the first time
   it returns SOME v for some v and then v is the result of the call to first_answer.
   If the first argument returns NONE for all list elements, then first_answer
   should raise the exception NoAnswer.
   Hints: Sample solution is 5 lines and does nothing fancy.
*)

fun first_answer is_wanted lst =
    case lst of
        []     => raise NoAnswer
      | x::xs' => case is_wanted x of
                      NONE   => first_answer is_wanted xs'
                    | SOME x => x

(*
8. Write a function all_answers of type (’a -> ’b list option) -> ’a list -> ’b list option
   (notice the 2 arguments are curried). The first argument should be applied to elements of the second
   argument. If it returns NONE for any element, then the result for all_answers is NONE. Else the
   calls to the first argument will have produced SOME lst1, SOME lst2, ... SOME lstn and the result of
   all_answers is SOME lst where lst is lst1, lst2, ..., lstn appended together (order doesn’t matter).
   Hints: The sample solution is 8 lines. It uses a helper function with an accumulator and uses @. Note
   all_answers f [] should evaluate to SOME [].
*)

fun all_answers is_wanted lst =
    let fun test_and_collect (lst, acc, all_good) =
            case lst of
                []     => if all_good then SOME(acc) else NONE
              | x::xs' => case is_wanted x of
                              NONE   => test_and_collect(xs', acc, false)
                            | SOME v => test_and_collect(xs', acc@v, all_good)
    in
        test_and_collect(lst, [], true)
    end

(*
9. (This problem uses the pattern datatype but is not really about pattern-matching.)
   A function g has been provided to you.
  (a) Use g to define a function count_wildcards that takes a pattern and
      returns how many Wildcard patterns it contains.
  (b) Use g to define a function count_wild_and_variable_lengths that
      takes a pattern and returns the number of Wildcard patterns it contains
      plus the sum of the string lengths of all the variables
      in the variable patterns it contains.
      (Use String.size. We care only about variable names;
        the constructor names are not relevant.)
  (c) Use g to define a function count_some_var that takes a string and
     a pattern (as a pair) and returns the number of times the string appears
     as a variable in the pattern. We care only about variable names;
     the constructor names are not relevant.
*)

fun count_wildcards pat =
	let val f1 = fn () => 1
		val f2 = fn x => 0
	in	
		g f1 f2 pat
	end

fun count_wild_and_variable_lengths pat =
	let val f1 = fn () => 1
		val f2 = fn s => String.size s
	in	
		g f1 f2 pat
	end

fun count_some_var (str, pat) =
	let val f1 = fn () => 0
		val same = fn s => if s = str then 1 else 0
	in
		g f1 same pat
	end

(*
10. Write a function check_pat that takes a pattern and returns true
    if and only if all the variables appearing in the pattern are
    distinct from each other (i.e., use different strings).
    The constructor names are not relevant.
    Hints: The sample solution uses two helper functions.
           The first takes a pattern and returns a list of all
           the strings it uses for variables. Using foldl with
           a function that uses append is useful in one case.
           The second takes a list of strings and decides if it
           has repeats. List.exists may be useful.
    Sample solution is 15 lines.
    These are hints: We are not requiring foldl and List.exists here,
    but they make it easier.
*)

fun check_pat pat =
	let fun collect_values (p, acc) =
			case p of
				Variable v => v :: acc
			  | TupleP ps  => List.foldl collect_values acc ps
			  | _	       => acc
	in
		case collect_values (pat, []) of
			[]     => true (* empty TAO has all possibilities *)
		  | x::xs' => not (List.exists (fn el => el = x) xs')
	end

(*
11. Write a function match that takes a valu * pattern and
    returns a (string * valu) list option, namely
       NONE if the pattern does not match and
       SOME lst where lst is the list of bindings if it does.
    Note that if the value matches but the pattern has no patterns
    of the form Variable s, then the result is SOME [].
    Hints: Sample solution has one case expression with 7 branches.
    The branch for tuples uses all_answers and ListPair.zip.
    Sample solution is 13 lines.
    Remember to look above for the rules for what patterns match what
    values, and what bindings they produce.
    These are hints: We are not requiring all_answers and ListPair.zip here,
    but they make it easier.
*)

(* stub *)
fun match (v, pat) =
	NONE

(*
12. Write a function first_match that takes a value and a list of patterns
    and returns a (string * valu) list option, namely
       NONE if no pattern in the list matches or
       SOME lst where lst is the list of bindings for the first pattern
         in the list that matches.
   Use first_answer and a handle-expression.
   Hints: Sample solution is 3 lines.
*)

(* TODO: challenge level exercises from pdf*)
